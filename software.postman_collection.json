{
	"info": {
		"_postman_id": "8f6803a6-bb01-40b2-9775-d77f1cdd9ad1",
		"name": "software",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "search",
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"term\": \"node.js\",\r\n    \"author\": \"Mahmoud Alfadel\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{Host}}/api/search/all",
					"host": [
						"{{Host}}"
					],
					"path": [
						"api",
						"search",
						"all"
					]
				},
				"description": "{\r\n    \"status\": true,\r\n    \"data\": [\r\n        {\r\n            \"_index\": \"software\",\r\n            \"_type\": \"ComputerScience\",\r\n            \"_id\": \"OaMikHYBDSiYng6L5BWx\",\r\n            \"_score\": 5.056336,\r\n            \"_source\": {\r\n                \"Url\": \"https://arxiv.org/abs/1507.02798\",\r\n                \"Title\": \"A horizontally-scalable multiprocessing platform based on Node.js\",\r\n                \"Rank\": \"1.5\",\r\n                \"NumberOfReference\": \"9\",\r\n                \"DateOfSubmitted\": \"2015\",\r\n                \"Info\": \"\",\r\n                \"Tags\": [\r\n                    \"Node.js\",\r\n                    \"AllFields\"\r\n                ],\r\n                \"status\": \"\"\r\n            }\r\n        },\r\n        {\r\n            \"_index\": \"software\",\r\n            \"_type\": \"ComputerScience\",\r\n            \"_id\": \"MqMikHYBDSiYng6L5BWn\",\r\n            \"_score\": 4.1605797,\r\n            \"_source\": {\r\n                \"Url\": \"https://arxiv.org/abs/1802.01790\",\r\n                \"Title\": \"Towards Runtime Monitoring of Node.js and Its Application to the Internet of Things\",\r\n                \"Rank\": \"2.6666666666666665\",\r\n                \"NumberOfReference\": \"8\",\r\n                \"DateOfSubmitted\": \"2018\",\r\n                \"Info\": \"\",\r\n                \"Tags\": [\r\n                    \"Node.js\",\r\n                    \"AllFields\"\r\n                ],\r\n                \"status\": \"\"\r\n            }\r\n        },\r\n        {\r\n            \"_index\": \"software\",\r\n            \"_type\": \"ComputerScience\",\r\n            \"_id\": \"NKMikHYBDSiYng6L5BWp\",\r\n            \"_score\": 5.532813,\r\n            \"_source\": {\r\n                \"Url\": \"https://arxiv.org/abs/1704.07887\",\r\n                \"Title\": \"RootJS: Node.js Bindings for ROOT 6\",\r\n                \"Rank\": \"0.5\",\r\n                \"NumberOfReference\": \"2\",\r\n                \"DateOfSubmitted\": \"2017\",\r\n                \"Info\": \"\",\r\n                \"Tags\": [\r\n                    \"Node.js\",\r\n                    \"AllFields\"\r\n                ],\r\n                \"status\": \"\"\r\n            }\r\n        },\r\n        {\r\n            \"_index\": \"software\",\r\n            \"_type\": \"ComputerScience\",\r\n            \"_id\": \"KKMikHYBDSiYng6L5BWZ\",\r\n            \"_score\": 4.4778924,\r\n            \"_source\": {\r\n                \"Url\": \"https://arxiv.org/abs/2008.04568\",\r\n                \"Title\": \"Code-based Vulnerability Detection in Node.js Applications: How far are we?\",\r\n                \"Rank\": \"1\",\r\n                \"NumberOfReference\": \"1\",\r\n                \"DateOfSubmitted\": \"2020\",\r\n                \"Info\": \"\",\r\n                \"Tags\": [\r\n                    \"Node.js\",\r\n                    \"AllFields\"\r\n                ],\r\n                \"status\": \"\"\r\n            }\r\n        },\r\n        {\r\n            \"_index\": \"software\",\r\n            \"_type\": \"ComputerScience\",\r\n            \"_id\": \"J6MikHYBDSiYng6L5BWU\",\r\n            \"_score\": 4.6554184,\r\n            \"_source\": {\r\n                \"Url\": \"https://arxiv.org/abs/2009.09019\",\r\n                \"Title\": \"On the Threat of npm Vulnerable Dependencies in Node.js Applications\",\r\n                \"Rank\": \"0\",\r\n                \"NumberOfReference\": \"0\",\r\n                \"DateOfSubmitted\": \"2020\",\r\n                \"Info\": \"\",\r\n                \"Tags\": [\r\n                    \"Node.js\",\r\n                    \"AllFields\"\r\n                ],\r\n                \"status\": \"\"\r\n            }\r\n        },\r\n        {\r\n            \"_index\": \"software\",\r\n            \"_type\": \"ComputerScience\",\r\n            \"_id\": \"KqMikHYBDSiYng6L5BWb\",\r\n            \"_score\": 5.2838545,\r\n            \"_source\": {\r\n                \"Url\": \"https://arxiv.org/abs/2004.05880\",\r\n                \"Title\": \"SecureIT using Firebase, Google map and Node.Js\",\r\n                \"Rank\": \"0\",\r\n                \"NumberOfReference\": \"0\",\r\n                \"DateOfSubmitted\": \"2020\",\r\n                \"Info\": \"\",\r\n                \"Tags\": [\r\n                    \"Node.js\",\r\n                    \"AllFields\"\r\n                ],\r\n                \"status\": \"\"\r\n            }\r\n        }\r\n    ]\r\n}"
			},
			"response": [
				{
					"name": "search without  \"author\"",
					"originalRequest": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"term\": \"node.js\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{Host}}/api/search/all",
							"host": [
								"{{Host}}"
							],
							"path": [
								"api",
								"search",
								"all"
							]
						}
					},
					"status": "OK",
					"code": 200,
					"_postman_previewlanguage": "json",
					"header": [
						{
							"key": "X-Powered-By",
							"value": "Express"
						},
						{
							"key": "Content-Type",
							"value": "application/json; charset=utf-8"
						},
						{
							"key": "Content-Length",
							"value": "30156"
						},
						{
							"key": "ETag",
							"value": "W/\"75cc-zeDnDe8P7ThqR6Qvsj82svSoMYc\""
						},
						{
							"key": "Date",
							"value": "Sat, 30 Jan 2021 06:12:35 GMT"
						},
						{
							"key": "Connection",
							"value": "keep-alive"
						}
					],
					"cookie": [],
					"body": "{\n    \"status\": true,\n    \"count\": 19,\n    \"data\": [\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"LMv0JncB9MRBP9xUUURi\",\n            \"_score\": 8.395829,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1901.05350\",\n                \"title\": \"TensorFlow.js: Machine Learning for the Web and Beyond\",\n                \"abstract\": \"TensorFlow.js is a library for building and executing machine learning algorithms in JavaScript. TensorFlow.js models run in a web browser and in the Node.js environment. The library is part of the TensorFlow ecosystem, providing a set of APIs that are compatible with those in Python, allowing models to be ported between the Python and JavaScript ecosystems. TensorFlow.js has empowered a new set of developers from the extensive JavaScript community to build and deploy machine learning models and enabled new classes of on-device computation. This paper describes the design, API, and implementation of TensorFlow.js, and highlights some of the impactful use cases.\",\n                \"authors\": \"Daniel Smilkov, Nikhil Thorat, Yannick Assogba, Ann Yuan, Nick Kreeger, Ping Yu, Kangyi Zhang, Shanqing Cai, Eric Nielsen, David Soergel, Stan Bileschi, Michael Terry, Charles Nicholson, Sandeep N. Gupta, Sarah Sirajuddin, D. Sculley, Rajat Monga, Greg Corrado, Fernanda B. Vi√©gas, Martin Wattenberg\",\n                \"rank\": \"27.5\",\n                \"citation\": \"55\",\n                \"year\": \"2019\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"K8v0JncB9MRBP9xUUURi\",\n            \"_score\": 7.0044956,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1903.12282\",\n                \"title\": \"An Empirical Study of Obsolete Answers on Stack Overflow\",\n                \"abstract\": \"Stack Overflow accumulates an enormous amount of software engineering knowledge. However, as time passes, certain knowledge in answers may become obsolete. Such obsolete answers, if not identified or documented clearly, may mislead answer seekers and cause unexpected problems (e.g., using an out-dated security protocol). In this paper, we investigate how the knowledge in answers becomes obsolete and identify the characteristics of such obsolete answers. We find that: 1) More than half of the obsolete answers (58.4%) were probably already obsolete when they were first posted. 2) When an obsolete answer is observed, only a small proportion (20.5%) of such answers are ever updated. 3) Answers to questions in certain tags (e.g., node.js, ajax, android, and objective-c) are more likely to become obsolete. Our findings suggest that Stack Overflow should develop mechanisms to encourage the whole community to maintain answers (to avoid obsolete answers) and answer seekers are encouraged to carefully go through all information (e.g., comments) in answer threads.\",\n                \"authors\": \"Haoxiang Zhang, Shaowei Wang, Tse-Hsun (Peter)Chen, Ying Zou, Ahmed E. Hassan\",\n                \"rank\": \"9\",\n                \"citation\": \"18\",\n                \"year\": \"2019\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Ncv0JncB9MRBP9xUUURi\",\n            \"_score\": 5.4548464,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1611.07862\",\n                \"title\": \"Browsix: Bridging the Gap Between Unix and the Browser\",\n                \"abstract\": \"Applications written to run on conventional operating systems typically depend on OS abstractions like processes, pipes, signals, sockets, and a shared file system. Porting these applications to the web currently requires extensive rewriting or hosting significant portions of code server-side because browsers present a nontraditional runtime environment that lacks OS functionality.\\nThis paper presents Browsix, a framework that bridges the considerable gap between conventional operating systems and the browser, enabling unmodified programs expecting a Unix-like environment to run directly in the browser. Browsix comprises two core parts: (1) a JavaScript-only system that makes core Unix features (including pipes, concurrent processes, signals, sockets, and a shared file system) available to web applications; and (2) extended JavaScript runtimes for C, C++, Go, and Node.js that support running programs written in these languages as processes in the browser. Browsix supports running a POSIX shell, making it straightforward to connect applications together via pipes.\\nWe illustrate Browsix's capabilities via case studies that demonstrate how it eases porting legacy applications to the browser and enables new functionality. We demonstrate a Browsix-enabled LaTeX editor that operates by executing unmodified versions of pdfLaTeX and BibTeX. This browser-only LaTeX editor can render documents in seconds, making it fast enough to be practical. We further demonstrate how Browsix lets us port a client-server application to run entirely in the browser for disconnected operation. Creating these applications required less than 50 lines of glue code and no code modifications, demonstrating how easily Browsix can be used to build sophisticated web applications from existing parts without modification.\",\n                \"authors\": \"Bobby Powers, John Vilk, Emery D. Berger\",\n                \"rank\": \"7\",\n                \"citation\": \"14\",\n                \"year\": \"2019\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Msv0JncB9MRBP9xUUURi\",\n            \"_score\": 19.52618,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1802.01790\",\n                \"title\": \"Towards Runtime Monitoring of Node.js and Its Application to the Internet of Things\",\n                \"abstract\": \"In the last years Node.js has emerged as a framework particularly suitable for implementing lightweight IoT applications, thanks to its underlying asynchronous event-driven, non blocking I/O model. However, verifying the correctness of programs with asynchronous nested callbacks is quite difficult, and, hence, runtime monitoring can be a valuable support to tackle such a complex task.\\nRuntime monitoring is a useful software verification technique that complements static analysis and testing, but has not been yet fully explored in the context of Internet of Things (IoT) systems. Trace expressions have been successfully employed for runtime monitoring in widespread multiagent system platforms. Recently, their expressive power has been extended to allow parametric specifications on data that can be captured and monitored only at runtime. Furthermore, they can be language and system agnostic, through the notion of event domain and type. This paper investigates the use of parametric trace expressions as a first step towards runtime monitoring of programs developed in Node.js and Node-RED, a flow-based IoT programming tool built on top of Node.js. Runtime verification of such systems is a task that mostly seems to have been overlooked so far in the literature.\\nA prototype implementing the proposed system for Node.js, in order to dynamically check with trace expressions the correct usage of API functions, is presented. The tool exploits the dynamic analysis framework Jalangi for monitoring Node.js programs and allows detection of errors that would be difficult to catch with other techniques. Furthermore, it offers a simple REST interface which can be exploited for runtime verification of Node-RED components, and, more generally, IoT devices.\",\n                \"authors\": \"Davide Ancona, Luca Franceschini, Giorgio Delzanno, Maurizio Leotta, Marina Ribaudo, Filippo Ricca\",\n                \"rank\": \"2.6666666666666665\",\n                \"citation\": \"8\",\n                \"year\": \"2018\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"L8v0JncB9MRBP9xUUURi\",\n            \"_score\": 7.0044956,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1810.05661\",\n                \"title\": \"Sound Regular Expression Semantics for Dynamic Symbolic Execution of JavaScript\",\n                \"abstract\": \"Existing support for regular expressions in automated test generation or verification tools is lacking. Common aspects of regular expression engines found in mainstream programming languages, such as backreferences or greedy matching, are commonly ignored or imprecisely approximated, leading to poor test coverage or failed proofs. In this paper, we present the first complete strategy to faithfully reason about regular expressions in the context of symbolic execution, focusing on the operators found in JavaScript. We model regular expression operations using string constraints and classical regular expressions and use a refinement scheme to address the problem of matching precedence and greediness. Our survey of over 400,000 JavaScript packages from the NPM software repository shows that one fifth make use of complex regular expressions features. We implemented our model in a dynamic symbolic execution engine for JavaScript and evaluated it on over 1,000 Node.js packages containing regular expressions, demonstrating that the strategy is effective and can increase line coverage of programs by up to 30%\",\n                \"authors\": \"Blake Loring, Duncan Mitchell, Johannes Kinder\",\n                \"rank\": \"7\",\n                \"citation\": \"7\",\n                \"year\": \"2020\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"PMv0JncB9MRBP9xUUURi\",\n            \"_score\": 6.3985786,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1407.1239\",\n                \"title\": \"RepNet: Cutting Tail Latency in Data Center Networks with Flow Replication\",\n                \"abstract\": \"Data center networks need to provide low latency, especially at the tail, as demanded by many interactive applications. To improve tail latency, existing approaches require modifications to switch hardware and/or end-host operating systems, making them difficult to be deployed. We present the design, implementation, and evaluation of RepNet, an application layer transport that can be deployed today. RepNet exploits the fact that only a few paths among many are congested at any moment in the network, and applies simple flow replication to mice flows to opportunistically use the less congested path. RepNet has two designs for flow replication: (1) RepSYN, which only replicates SYN packets and uses the first connection that finishes TCP handshaking for data transmission, and (2) RepFlow which replicates the entire mice flow. We implement RepNet on {\\\\tt node.js}, one of the most commonly used platforms for networked interactive applications. {\\\\tt node}'s single threaded event-loop and non-blocking I/O make flow replication highly efficient. Performance evaluation on a real network testbed and in Mininet reveals that RepNet is able to reduce the tail latency of mice flows, as well as application completion times, by more than 50\\\\%.\",\n                \"authors\": \"Shuhao Liu, Wei Bai, Hong Xu, Kai Chen, Zhiping Cai\",\n                \"rank\": \"0.8333333333333334\",\n                \"citation\": \"5\",\n                \"year\": \"2015\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"N8v0JncB9MRBP9xUUURi\",\n            \"_score\": 7.1743402,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1607.05402\",\n                \"title\": \"Web Based Teleoperation of a Humanoid Robot\",\n                \"abstract\": \"The Cloud-based Advanced Robotics Laboratory (CARL) integrates a whole body controller and web-based teleoperation to enable any device with a web browser to access and control a humanoid robot. By integrating humanoid robots with the cloud, they are accessible from any Internet-connected device. Increased accessibility is important because few people have access to state-of-the-art humanoid robots limiting their rate of development. CARL's implementation is based on modern software libraries, frameworks, and middleware including Node.js, this http URL, ZMQ, ROS, Robot Web Tools, and ControlIt! Feasibility is demonstrated by having inexperienced human operators use a smartphone's web-browser to control Dreamer, a torque-controlled humanoid robot based on series elastic actuators, and make it perform a dual-arm manipulation task. The implementation serves as a proof-of-concept and foundation upon which many advanced humanoid robot technologies can be researched and developed.\",\n                \"authors\": \"Chien Liang Fok, Fei Sun, Matt Mangum, Al Mok, Binghan He, Luis Sentis\",\n                \"rank\": \"0.6\",\n                \"citation\": \"3\",\n                \"year\": \"2016\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"O8v0JncB9MRBP9xUUURi\",\n            \"_score\": 7.539998,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1407.3000\",\n                \"title\": \"A Proposed Infrastructure for Adding Online Interaction to Any Evolutionary Domain\",\n                \"abstract\": \"To address the difficulty of creating online collaborative evolutionary systems, this paper presents a new prototype library called Worldwide Infrastructure for Neuroevolution (WIN) and its accompanying site WIN Online (this http URL). The WIN library is a collection of software packages built on top of Node.js that reduce the complexity of creating fully persistent, online, and interactive (or automated) evolutionary platforms around any domain. WIN Online is the public interface for WIN, providing an online collection of domains built with the WIN library that lets novice and expert users browse and meaningfully contribute to ongoing experiments. The long term goal of WIN is to make it trivial to connect any platform to the world, providing both a stream of online users, and archives of data and discoveries for later extension by humans or computers.\",\n                \"authors\": \"Paul Szerlip, Kenneth O. Stanley\",\n                \"rank\": \"0.2857142857142857\",\n                \"citation\": \"2\",\n                \"year\": \"2014\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"NMv0JncB9MRBP9xUUURi\",\n            \"_score\": 23.749582,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1704.07887\",\n                \"title\": \"RootJS: Node.js Bindings for ROOT 6\",\n                \"abstract\": \"We present rootJS, an interface making it possible to seamlessly integrate ROOT 6 into applications written for Node.js, the JavaScript runtime platform increasingly commonly used to create high-performance Web applications. ROOT features can be called both directly from Node.js code and by JIT-compiling C++ macros. All rootJS methods are invoked asynchronously and support callback functions, allowing non-blocking operation of Node.js applications using them. Last but not least, our bindings have been designed to platform-independent and should therefore work on all systems supporting both ROOT 6 and Node.js.\\nThanks to rootJS it is now possible to create ROOT-aware Web applications taking full advantage of the high performance and extensive capabilities of Node.js. Examples include platforms for the quality assurance of acquired, reconstructed or simulated data, book-keeping and e-log systems, and even Web browser-based data visualisation and analysis.\",\n                \"authors\": \"Theo Beffart, Maximilian Fr√ºh, Christoph Haas, Sachin Rajgopal, Jonas Schwabe, Christoph Wolff, Marek Szuba\",\n                \"rank\": \"0.5\",\n                \"citation\": \"2\",\n                \"year\": \"2017\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Lcv0JncB9MRBP9xUUURi\",\n            \"_score\": 6.6878414,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1812.05160\",\n                \"title\": \"An Interactive, Graphical CPU Scheduling Simulator for Teaching Operating Systems\",\n                \"abstract\": \"We present a graphical simulation tool for visually and interactively exploring the processing of various events handled by an operating system when running a program. Our graphical simulator is available for use on the web and locally by both instructors and students for purposes of pedagogy. Instructors can use it for live demonstrations of course concepts in class, while students can use it outside of class to explore the concepts. The graphical simulation tool is implemented using the React library for the fancy ui elements of the Node.js framework and is available as a single page web application at this https URL. Assigning the development of the underling text-based simulation engine, on which the graphical simulator runs, to students as a course project is also an effective approach to teach students the concepts. The goals of this paper are to showcase the demonstrative capabilities of the tool for instruction, share student experiences in developing the engine underlying the simulation, and to inspire its use by other educators.\",\n                \"authors\": \"Joshua W. Buck, Saverio Perugini\",\n                \"rank\": \"0.5\",\n                \"citation\": \"1\",\n                \"year\": \"2019\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Nsv0JncB9MRBP9xUUURi\",\n            \"_score\": 7.0044956,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1609.01676\",\n                \"title\": \"An IoT application development using IoTSuite\",\n                \"abstract\": \"Application development in the Internet of Things (IoT) is challenging because it involves dealing with issues that attribute to different life-cycle phases. First, the application logic has to be analyzed and then separated into a set of distributed tasks for an underlying network. Then, the tasks have to be implemented for the specific hardware. Moreover, we take different IoT applications and present development of these applications using IoTSuite. In this paper, we introduce a design and implementation of ToolSuite, a suite of tools, for reducing burden of each stage of IoT application development process. We take different class of IoT applications, largely found in the IoT literature, and demonstrate these IoT application development using IoTSuite. These applications have been tested on several IoT technologies such as Android, Raspberry PI, Arduino, and JavaSE-enabled devices, Messaging protocols such as MQTT, CoAP, WebSocket, Server technologies such as Node.js, Relational database such as MySQL, and Microsoft Azure Cloud services.\",\n                \"authors\": \"Saurabh Chauhan, Pankesh Patel\",\n                \"rank\": \"0.2\",\n                \"citation\": \"1\",\n                \"year\": \"2016\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Osv0JncB9MRBP9xUUURi\",\n            \"_score\": 7.352626,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1503.01398\",\n                \"title\": \"Node.DPWS: High performance and scalable Web Services for the IoT\",\n                \"abstract\": \"Interconnected computing systems, in various forms, are expected to permeate our lives, realizing the vision of the Internet of Things (IoT) and allowing us to enjoy novel, enhanced services that promise to improve our everyday lives. Nevertheless, this new reality also introduces significant challenges in terms of performance, scaling, usability and interoperability. Leveraging the benefits of Service Oriented Architectures (SOAs) can help alleviate many of the issues that developers, implementers and end-users have to face in the context of the IoT. This work presents Node.DPWS, a novel implementation of the Devices Profile for Web Services (DPWS) based on the Node.js platform. Node.DPWS can be used to deploy lightweight, efficient and scalable Web Services over heterogeneous nodes, including devices with limited resources. The performance of the presented work is evaluated on typical embedded devices, including comparisons with implementations created using alternative DPWS toolkits.\",\n                \"authors\": \"Konstantinos Fysarakis (1), Damianos Mylonakis (2), Charalampos Manifavas (3), Ioannis Papaefstathiou (1) ((1) Dept. of Electronic & Computer Engineering, Technical University of Crete, Greece, (2) Dept. of Computer Science, University of Crete, Greece, (3) Dept. of Informatics Engineering, Technological Educational Institute of Crete, Greece)\",\n                \"rank\": \"0.16666666666666666\",\n                \"citation\": \"1\",\n                \"year\": \"2015\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Kcv0JncB9MRBP9xUUURi\",\n            \"_score\": 5.889144,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/2007.03302\",\n                \"title\": \"VPS: Excavating High-Level C++ Constructs from Low-Level Binaries to Protect Dynamic Dispatching\",\n                \"abstract\": \"Polymorphism and inheritance make C++ suitable for writing complex software, but significantly increase the attack surface because the implementation relies on virtual function tables (vtables). These vtables contain function pointers that attackers can potentially hijack and in practice, vtable hijacking is one of the most important attack vector for C++ binaries.\\nIn this paper, we present VTable Pointer Separation (VPS), a practical binary-level defense against vtable hijacking in C++ applications. Unlike previous binary-level defenses, which rely on unsound static analyses to match classes to virtual callsites, VPS achieves a more accurate protection by restricting virtual callsites to validly created objects. More specifically, VPS ensures that virtual callsites can only use objects created at valid object construction sites, and only if those objects can reach the callsite. Moreover, VPS explicitly prevents false positives (falsely identified virtual callsites) from breaking the binary, an issue existing work does not handle correctly or at all. We evaluate the prototype implementation of VPS on a diverse set of complex, real-world applications (MongoDB, MySQL server, Node.js, SPEC CPU2017/CPU2006), showing that our approach protects on average 97.8% of all virtual callsites in SPEC CPU2006 and 97.4% in SPEC CPU2017 (all C++ benchmarks), with a moderate performance overhead of 11% and 9% geomean, respectively. Furthermore, our evaluation reveals 86 false negatives in VTV, a popular source-based defense which is part of GCC.\",\n                \"authors\": \"Andre Pawlowski, Victor van der Veen, Dennis Andriesse, Erik van der Kouwe, Thorsten Holz, Cristiano Giuffrida, Herbert Bos\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2020\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"MMv0JncB9MRBP9xUUURi\",\n            \"_score\": 7.352626,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1809.10956\",\n                \"title\": \"Coconut E-Petition Implementation\",\n                \"abstract\": \"In this dissertation project, we describe and implement a practical system application based on a selective disclosure credential scheme, namely the Coconut credential scheme\\\\cite{sonnino_coconut:_2018}. The specific application here is an electronic petition system with the distinctive added feature of unlinkability as well as anonymity: such that no information about the anonymous petition voter is linkable back to the individual. In other words, there is no data leaked about who voted in the petition, just that the users who did, were indeed eligible and authorized to vote. As for the implementation, the client-side is done using JavaScript so that the client can trustlessly compute the cryptographic constructions individually, whereas the server-side is done using Node.js, but can easily be replaced by a more sophisticated and secure structure such as a permissionless blockchain platform.\",\n                \"authors\": \"Jad Wahab\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2018\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"OMv0JncB9MRBP9xUUURi\",\n            \"_score\": 7.737171,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1602.03681\",\n                \"title\": \"Package equivalence in complex software network\",\n                \"abstract\": \"The public package registry npm is one of the biggest software registry. With its 216 911 software packages, it forms a big network of software dependencies. In this paper we evaluate various methods for finding similar packages in the npm network, using only the structure of the graph. Namely, we want to find a way of categorizing similar packages, which would be useful for recommendation systems. This size enables us to compute meaningful results, as it softened the particularities of the graph. Npm is also quite famous as it is the default package repository of Node.js. We believe that it will make our results interesting for more people than a less used package repository. This makes it a good subject of analysis of software networks.\",\n                \"authors\": \"Tomislav Slijepƒçeviƒá\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2016\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"M8v0JncB9MRBP9xUUURi\",\n            \"_score\": 8.641029,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1705.04317\",\n                \"title\": \"Management system for the SND experiments\",\n                \"abstract\": \"A new management system for the SND detector experiments (at VEPP-2000 collider in Novosibirsk) is developed. We describe here the interaction between a user and the SND databases. These databases contain experiment configuration, conditions and metadata. The new system is designed in client-server architecture. It has several logical layers corresponding to the users roles. A new template engine is created. A web application is implemented using Node.js framework. At the time the application provides: showing and editing configuration; showing experiment metadata and experiment conditions data index; showing SND log (prototype).\",\n                \"authors\": \"A. Korol, K. Pugachev\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2017\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Lsv0JncB9MRBP9xUUURi\",\n            \"_score\": 8.9498825,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1811.05945\",\n                \"title\": \"Mayall: A Framework for Desktop JavaScript Auditing and Post-Exploitation Analysis\",\n                \"abstract\": \"Writing desktop applications in JavaScript offers developers the opportunity to write cross-platform applications with cutting edge capabilities. However in doing so, they are potentially submitting their code to a number of unsanctioned modifications from malicious actors. Electron is one such JavaScript application framework which facilitates this multi-platform out-the-box paradigm and is based upon the Node.js JavaScript runtime --- an increasingly popular server-side technology. In bringing this technology to the client-side environment, previously unrealized risks are exposed to users due to the powerful system programming interface that Node.js exposes. In a concerted effort to highlight previously unexposed risks in these rapidly expanding frameworks, this paper presents the Mayall Framework, an extensible toolkit aimed at JavaScript security auditing and post-exploitation analysis. The paper also exposes fifteen highly popular Electron applications and demonstrates that two thirds of applications were found to be using known vulnerable elements with high CVSS scores. Moreover, this paper discloses a wide-reaching and overlooked vulnerability within the Electron Framework which is a direct byproduct of shipping the runtime unaltered with each application, allowing malicious actors to modify source code and inject covert malware inside verified and signed applications without restriction. Finally, a number of injection vectors are explored and appropriate remediations are proposed.\",\n                \"authors\": \"Adam Rapley, Xavier Bellekens, Lynsay A. Shepherd, Colin McLean\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2018\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Ksv0JncB9MRBP9xUUURi\",\n            \"_score\": 15.400597,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/2004.05880\",\n                \"title\": \"SecureIT using Firebase, Google map and Node.Js\",\n                \"abstract\": \"This paper is about describing the features of a software that was developed for its user safety which we called SecureIT is a android based soft ware using Android SDK along with Firebase and Google map SDK along with Node.Js. The aim of developing this project was to make sure and taking its users safety to a next level. Actually now a days some crime incidents like rapes, fire accidents and snatchings are very common and we believe many of those can be prevented if victim got support at the right time. According to the well known daily news paper of Bangladesh The Daily Star there were about 1413 women was rapped where 76 women were dead in 2019. On the same pa-per it also said that in 2018 and 2017 the number of rapes were 732 and 818 where we can easily get that the number increases to almost double in 2019. Where we get a point that if those girls get support or get people known about their location at the right time they might get rid of the situation and the number of rapes could be reduced a lot because we all know that now a days using mo-bile smartphone is too easy for people. Although leading Chinese mobile phone company Xiaomi introduced a new feature Emergency SOS service in their mobile phones at the end of 2018 with a MIUI 10 update but this feature is only limited to the Xiaomi phones and it was well advertised as well. This paper will briefly describe all the features of our software and its usages.\",\n                \"authors\": \"Shanta Khatun, Fahim Hossain Saiki, Milon Biswas\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2020\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Psv0JncB9MRBP9xUUURi\",\n            \"_score\": 16.893684,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/2009.09019\",\n                \"title\": \"On the Threat of npm Vulnerable Dependencies in Node.js Applications\",\n                \"abstract\": \"Software vulnerabilities have a large negative impact on the software systems that we depend on daily. Reports on software vulnerabilities always paint a grim picture, with some reports showing that 83% of organizations depend on vulnerable software. However, our experience leads us to believe that, in the grand scheme of things, these software vulnerabilities may have less impact than what is reported. Therefore, we perform a study to better understand the threat of npm vulnerable packages used in Node.js applications. We define three threat levels for vulnerabilities in packages, based on their lifecycle, where a package vulnerability is assigned a low threat level if it was hidden or still unknown at the time it was used in the dependent application (t), medium threat level if the vulnerability was reported but not yet published at t, and high if it was publicly announced at t. Then, we perform an empirical study involving 6,673 real-world, active, and mature open source Node.js applications. Our findings show that although 67.93% of the examined applications depend on at least one vulnerable package, 94.91% of the vulnerable packages in those affected applications are classified as having low threat. Moreover, we find that in the case of vulnerable packages classified as having high threat, it is the application's lack of updating that makes them vulnerable, i.e., it is not the existence of the vulnerability that is the real problem. Furthermore, we verify our findings at different stages of the application's lifetime and find that our findings still hold. Our study argues that when it comes to software vulnerabilities, things may not be as bad as they seem and that considering vulnerability threat is key.\",\n                \"authors\": \"Mahmoud Alfadel, Diego Elias Costa, Mouafak Mokhallalati, Emad Shihab, Bram Adams\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2020\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        }\n    ]\n}"
				},
				{
					"name": "search all fields",
					"originalRequest": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"term\": \"node.js\",\r\n    \"author\": \"Mahmoud Alfadel\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{Host}}/api/search/all",
							"host": [
								"{{Host}}"
							],
							"path": [
								"api",
								"search",
								"all"
							]
						}
					},
					"status": "OK",
					"code": 200,
					"_postman_previewlanguage": "json",
					"header": [
						{
							"key": "X-Powered-By",
							"value": "Express"
						},
						{
							"key": "Content-Type",
							"value": "application/json; charset=utf-8"
						},
						{
							"key": "Content-Length",
							"value": "30156"
						},
						{
							"key": "ETag",
							"value": "W/\"75cc-JFM1EDEsLV6zDiCXTOVtwytzKBo\""
						},
						{
							"key": "Date",
							"value": "Sat, 30 Jan 2021 06:10:42 GMT"
						},
						{
							"key": "Connection",
							"value": "keep-alive"
						}
					],
					"cookie": [],
					"body": "{\n    \"status\": true,\n    \"count\": 19,\n    \"data\": [\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"LMv0JncB9MRBP9xUUURi\",\n            \"_score\": 8.395829,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1901.05350\",\n                \"title\": \"TensorFlow.js: Machine Learning for the Web and Beyond\",\n                \"abstract\": \"TensorFlow.js is a library for building and executing machine learning algorithms in JavaScript. TensorFlow.js models run in a web browser and in the Node.js environment. The library is part of the TensorFlow ecosystem, providing a set of APIs that are compatible with those in Python, allowing models to be ported between the Python and JavaScript ecosystems. TensorFlow.js has empowered a new set of developers from the extensive JavaScript community to build and deploy machine learning models and enabled new classes of on-device computation. This paper describes the design, API, and implementation of TensorFlow.js, and highlights some of the impactful use cases.\",\n                \"authors\": \"Daniel Smilkov, Nikhil Thorat, Yannick Assogba, Ann Yuan, Nick Kreeger, Ping Yu, Kangyi Zhang, Shanqing Cai, Eric Nielsen, David Soergel, Stan Bileschi, Michael Terry, Charles Nicholson, Sandeep N. Gupta, Sarah Sirajuddin, D. Sculley, Rajat Monga, Greg Corrado, Fernanda B. Vi√©gas, Martin Wattenberg\",\n                \"rank\": \"27.5\",\n                \"citation\": \"55\",\n                \"year\": \"2019\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"K8v0JncB9MRBP9xUUURi\",\n            \"_score\": 7.0044956,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1903.12282\",\n                \"title\": \"An Empirical Study of Obsolete Answers on Stack Overflow\",\n                \"abstract\": \"Stack Overflow accumulates an enormous amount of software engineering knowledge. However, as time passes, certain knowledge in answers may become obsolete. Such obsolete answers, if not identified or documented clearly, may mislead answer seekers and cause unexpected problems (e.g., using an out-dated security protocol). In this paper, we investigate how the knowledge in answers becomes obsolete and identify the characteristics of such obsolete answers. We find that: 1) More than half of the obsolete answers (58.4%) were probably already obsolete when they were first posted. 2) When an obsolete answer is observed, only a small proportion (20.5%) of such answers are ever updated. 3) Answers to questions in certain tags (e.g., node.js, ajax, android, and objective-c) are more likely to become obsolete. Our findings suggest that Stack Overflow should develop mechanisms to encourage the whole community to maintain answers (to avoid obsolete answers) and answer seekers are encouraged to carefully go through all information (e.g., comments) in answer threads.\",\n                \"authors\": \"Haoxiang Zhang, Shaowei Wang, Tse-Hsun (Peter)Chen, Ying Zou, Ahmed E. Hassan\",\n                \"rank\": \"9\",\n                \"citation\": \"18\",\n                \"year\": \"2019\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Ncv0JncB9MRBP9xUUURi\",\n            \"_score\": 5.4548464,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1611.07862\",\n                \"title\": \"Browsix: Bridging the Gap Between Unix and the Browser\",\n                \"abstract\": \"Applications written to run on conventional operating systems typically depend on OS abstractions like processes, pipes, signals, sockets, and a shared file system. Porting these applications to the web currently requires extensive rewriting or hosting significant portions of code server-side because browsers present a nontraditional runtime environment that lacks OS functionality.\\nThis paper presents Browsix, a framework that bridges the considerable gap between conventional operating systems and the browser, enabling unmodified programs expecting a Unix-like environment to run directly in the browser. Browsix comprises two core parts: (1) a JavaScript-only system that makes core Unix features (including pipes, concurrent processes, signals, sockets, and a shared file system) available to web applications; and (2) extended JavaScript runtimes for C, C++, Go, and Node.js that support running programs written in these languages as processes in the browser. Browsix supports running a POSIX shell, making it straightforward to connect applications together via pipes.\\nWe illustrate Browsix's capabilities via case studies that demonstrate how it eases porting legacy applications to the browser and enables new functionality. We demonstrate a Browsix-enabled LaTeX editor that operates by executing unmodified versions of pdfLaTeX and BibTeX. This browser-only LaTeX editor can render documents in seconds, making it fast enough to be practical. We further demonstrate how Browsix lets us port a client-server application to run entirely in the browser for disconnected operation. Creating these applications required less than 50 lines of glue code and no code modifications, demonstrating how easily Browsix can be used to build sophisticated web applications from existing parts without modification.\",\n                \"authors\": \"Bobby Powers, John Vilk, Emery D. Berger\",\n                \"rank\": \"7\",\n                \"citation\": \"14\",\n                \"year\": \"2019\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Msv0JncB9MRBP9xUUURi\",\n            \"_score\": 19.52618,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1802.01790\",\n                \"title\": \"Towards Runtime Monitoring of Node.js and Its Application to the Internet of Things\",\n                \"abstract\": \"In the last years Node.js has emerged as a framework particularly suitable for implementing lightweight IoT applications, thanks to its underlying asynchronous event-driven, non blocking I/O model. However, verifying the correctness of programs with asynchronous nested callbacks is quite difficult, and, hence, runtime monitoring can be a valuable support to tackle such a complex task.\\nRuntime monitoring is a useful software verification technique that complements static analysis and testing, but has not been yet fully explored in the context of Internet of Things (IoT) systems. Trace expressions have been successfully employed for runtime monitoring in widespread multiagent system platforms. Recently, their expressive power has been extended to allow parametric specifications on data that can be captured and monitored only at runtime. Furthermore, they can be language and system agnostic, through the notion of event domain and type. This paper investigates the use of parametric trace expressions as a first step towards runtime monitoring of programs developed in Node.js and Node-RED, a flow-based IoT programming tool built on top of Node.js. Runtime verification of such systems is a task that mostly seems to have been overlooked so far in the literature.\\nA prototype implementing the proposed system for Node.js, in order to dynamically check with trace expressions the correct usage of API functions, is presented. The tool exploits the dynamic analysis framework Jalangi for monitoring Node.js programs and allows detection of errors that would be difficult to catch with other techniques. Furthermore, it offers a simple REST interface which can be exploited for runtime verification of Node-RED components, and, more generally, IoT devices.\",\n                \"authors\": \"Davide Ancona, Luca Franceschini, Giorgio Delzanno, Maurizio Leotta, Marina Ribaudo, Filippo Ricca\",\n                \"rank\": \"2.6666666666666665\",\n                \"citation\": \"8\",\n                \"year\": \"2018\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"L8v0JncB9MRBP9xUUURi\",\n            \"_score\": 7.0044956,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1810.05661\",\n                \"title\": \"Sound Regular Expression Semantics for Dynamic Symbolic Execution of JavaScript\",\n                \"abstract\": \"Existing support for regular expressions in automated test generation or verification tools is lacking. Common aspects of regular expression engines found in mainstream programming languages, such as backreferences or greedy matching, are commonly ignored or imprecisely approximated, leading to poor test coverage or failed proofs. In this paper, we present the first complete strategy to faithfully reason about regular expressions in the context of symbolic execution, focusing on the operators found in JavaScript. We model regular expression operations using string constraints and classical regular expressions and use a refinement scheme to address the problem of matching precedence and greediness. Our survey of over 400,000 JavaScript packages from the NPM software repository shows that one fifth make use of complex regular expressions features. We implemented our model in a dynamic symbolic execution engine for JavaScript and evaluated it on over 1,000 Node.js packages containing regular expressions, demonstrating that the strategy is effective and can increase line coverage of programs by up to 30%\",\n                \"authors\": \"Blake Loring, Duncan Mitchell, Johannes Kinder\",\n                \"rank\": \"7\",\n                \"citation\": \"7\",\n                \"year\": \"2020\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"PMv0JncB9MRBP9xUUURi\",\n            \"_score\": 6.3985786,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1407.1239\",\n                \"title\": \"RepNet: Cutting Tail Latency in Data Center Networks with Flow Replication\",\n                \"abstract\": \"Data center networks need to provide low latency, especially at the tail, as demanded by many interactive applications. To improve tail latency, existing approaches require modifications to switch hardware and/or end-host operating systems, making them difficult to be deployed. We present the design, implementation, and evaluation of RepNet, an application layer transport that can be deployed today. RepNet exploits the fact that only a few paths among many are congested at any moment in the network, and applies simple flow replication to mice flows to opportunistically use the less congested path. RepNet has two designs for flow replication: (1) RepSYN, which only replicates SYN packets and uses the first connection that finishes TCP handshaking for data transmission, and (2) RepFlow which replicates the entire mice flow. We implement RepNet on {\\\\tt node.js}, one of the most commonly used platforms for networked interactive applications. {\\\\tt node}'s single threaded event-loop and non-blocking I/O make flow replication highly efficient. Performance evaluation on a real network testbed and in Mininet reveals that RepNet is able to reduce the tail latency of mice flows, as well as application completion times, by more than 50\\\\%.\",\n                \"authors\": \"Shuhao Liu, Wei Bai, Hong Xu, Kai Chen, Zhiping Cai\",\n                \"rank\": \"0.8333333333333334\",\n                \"citation\": \"5\",\n                \"year\": \"2015\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"N8v0JncB9MRBP9xUUURi\",\n            \"_score\": 7.1743402,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1607.05402\",\n                \"title\": \"Web Based Teleoperation of a Humanoid Robot\",\n                \"abstract\": \"The Cloud-based Advanced Robotics Laboratory (CARL) integrates a whole body controller and web-based teleoperation to enable any device with a web browser to access and control a humanoid robot. By integrating humanoid robots with the cloud, they are accessible from any Internet-connected device. Increased accessibility is important because few people have access to state-of-the-art humanoid robots limiting their rate of development. CARL's implementation is based on modern software libraries, frameworks, and middleware including Node.js, this http URL, ZMQ, ROS, Robot Web Tools, and ControlIt! Feasibility is demonstrated by having inexperienced human operators use a smartphone's web-browser to control Dreamer, a torque-controlled humanoid robot based on series elastic actuators, and make it perform a dual-arm manipulation task. The implementation serves as a proof-of-concept and foundation upon which many advanced humanoid robot technologies can be researched and developed.\",\n                \"authors\": \"Chien Liang Fok, Fei Sun, Matt Mangum, Al Mok, Binghan He, Luis Sentis\",\n                \"rank\": \"0.6\",\n                \"citation\": \"3\",\n                \"year\": \"2016\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"O8v0JncB9MRBP9xUUURi\",\n            \"_score\": 7.539998,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1407.3000\",\n                \"title\": \"A Proposed Infrastructure for Adding Online Interaction to Any Evolutionary Domain\",\n                \"abstract\": \"To address the difficulty of creating online collaborative evolutionary systems, this paper presents a new prototype library called Worldwide Infrastructure for Neuroevolution (WIN) and its accompanying site WIN Online (this http URL). The WIN library is a collection of software packages built on top of Node.js that reduce the complexity of creating fully persistent, online, and interactive (or automated) evolutionary platforms around any domain. WIN Online is the public interface for WIN, providing an online collection of domains built with the WIN library that lets novice and expert users browse and meaningfully contribute to ongoing experiments. The long term goal of WIN is to make it trivial to connect any platform to the world, providing both a stream of online users, and archives of data and discoveries for later extension by humans or computers.\",\n                \"authors\": \"Paul Szerlip, Kenneth O. Stanley\",\n                \"rank\": \"0.2857142857142857\",\n                \"citation\": \"2\",\n                \"year\": \"2014\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"NMv0JncB9MRBP9xUUURi\",\n            \"_score\": 23.749582,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1704.07887\",\n                \"title\": \"RootJS: Node.js Bindings for ROOT 6\",\n                \"abstract\": \"We present rootJS, an interface making it possible to seamlessly integrate ROOT 6 into applications written for Node.js, the JavaScript runtime platform increasingly commonly used to create high-performance Web applications. ROOT features can be called both directly from Node.js code and by JIT-compiling C++ macros. All rootJS methods are invoked asynchronously and support callback functions, allowing non-blocking operation of Node.js applications using them. Last but not least, our bindings have been designed to platform-independent and should therefore work on all systems supporting both ROOT 6 and Node.js.\\nThanks to rootJS it is now possible to create ROOT-aware Web applications taking full advantage of the high performance and extensive capabilities of Node.js. Examples include platforms for the quality assurance of acquired, reconstructed or simulated data, book-keeping and e-log systems, and even Web browser-based data visualisation and analysis.\",\n                \"authors\": \"Theo Beffart, Maximilian Fr√ºh, Christoph Haas, Sachin Rajgopal, Jonas Schwabe, Christoph Wolff, Marek Szuba\",\n                \"rank\": \"0.5\",\n                \"citation\": \"2\",\n                \"year\": \"2017\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Lcv0JncB9MRBP9xUUURi\",\n            \"_score\": 6.6878414,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1812.05160\",\n                \"title\": \"An Interactive, Graphical CPU Scheduling Simulator for Teaching Operating Systems\",\n                \"abstract\": \"We present a graphical simulation tool for visually and interactively exploring the processing of various events handled by an operating system when running a program. Our graphical simulator is available for use on the web and locally by both instructors and students for purposes of pedagogy. Instructors can use it for live demonstrations of course concepts in class, while students can use it outside of class to explore the concepts. The graphical simulation tool is implemented using the React library for the fancy ui elements of the Node.js framework and is available as a single page web application at this https URL. Assigning the development of the underling text-based simulation engine, on which the graphical simulator runs, to students as a course project is also an effective approach to teach students the concepts. The goals of this paper are to showcase the demonstrative capabilities of the tool for instruction, share student experiences in developing the engine underlying the simulation, and to inspire its use by other educators.\",\n                \"authors\": \"Joshua W. Buck, Saverio Perugini\",\n                \"rank\": \"0.5\",\n                \"citation\": \"1\",\n                \"year\": \"2019\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Nsv0JncB9MRBP9xUUURi\",\n            \"_score\": 7.0044956,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1609.01676\",\n                \"title\": \"An IoT application development using IoTSuite\",\n                \"abstract\": \"Application development in the Internet of Things (IoT) is challenging because it involves dealing with issues that attribute to different life-cycle phases. First, the application logic has to be analyzed and then separated into a set of distributed tasks for an underlying network. Then, the tasks have to be implemented for the specific hardware. Moreover, we take different IoT applications and present development of these applications using IoTSuite. In this paper, we introduce a design and implementation of ToolSuite, a suite of tools, for reducing burden of each stage of IoT application development process. We take different class of IoT applications, largely found in the IoT literature, and demonstrate these IoT application development using IoTSuite. These applications have been tested on several IoT technologies such as Android, Raspberry PI, Arduino, and JavaSE-enabled devices, Messaging protocols such as MQTT, CoAP, WebSocket, Server technologies such as Node.js, Relational database such as MySQL, and Microsoft Azure Cloud services.\",\n                \"authors\": \"Saurabh Chauhan, Pankesh Patel\",\n                \"rank\": \"0.2\",\n                \"citation\": \"1\",\n                \"year\": \"2016\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Osv0JncB9MRBP9xUUURi\",\n            \"_score\": 7.352626,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1503.01398\",\n                \"title\": \"Node.DPWS: High performance and scalable Web Services for the IoT\",\n                \"abstract\": \"Interconnected computing systems, in various forms, are expected to permeate our lives, realizing the vision of the Internet of Things (IoT) and allowing us to enjoy novel, enhanced services that promise to improve our everyday lives. Nevertheless, this new reality also introduces significant challenges in terms of performance, scaling, usability and interoperability. Leveraging the benefits of Service Oriented Architectures (SOAs) can help alleviate many of the issues that developers, implementers and end-users have to face in the context of the IoT. This work presents Node.DPWS, a novel implementation of the Devices Profile for Web Services (DPWS) based on the Node.js platform. Node.DPWS can be used to deploy lightweight, efficient and scalable Web Services over heterogeneous nodes, including devices with limited resources. The performance of the presented work is evaluated on typical embedded devices, including comparisons with implementations created using alternative DPWS toolkits.\",\n                \"authors\": \"Konstantinos Fysarakis (1), Damianos Mylonakis (2), Charalampos Manifavas (3), Ioannis Papaefstathiou (1) ((1) Dept. of Electronic & Computer Engineering, Technical University of Crete, Greece, (2) Dept. of Computer Science, University of Crete, Greece, (3) Dept. of Informatics Engineering, Technological Educational Institute of Crete, Greece)\",\n                \"rank\": \"0.16666666666666666\",\n                \"citation\": \"1\",\n                \"year\": \"2015\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Kcv0JncB9MRBP9xUUURi\",\n            \"_score\": 5.889144,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/2007.03302\",\n                \"title\": \"VPS: Excavating High-Level C++ Constructs from Low-Level Binaries to Protect Dynamic Dispatching\",\n                \"abstract\": \"Polymorphism and inheritance make C++ suitable for writing complex software, but significantly increase the attack surface because the implementation relies on virtual function tables (vtables). These vtables contain function pointers that attackers can potentially hijack and in practice, vtable hijacking is one of the most important attack vector for C++ binaries.\\nIn this paper, we present VTable Pointer Separation (VPS), a practical binary-level defense against vtable hijacking in C++ applications. Unlike previous binary-level defenses, which rely on unsound static analyses to match classes to virtual callsites, VPS achieves a more accurate protection by restricting virtual callsites to validly created objects. More specifically, VPS ensures that virtual callsites can only use objects created at valid object construction sites, and only if those objects can reach the callsite. Moreover, VPS explicitly prevents false positives (falsely identified virtual callsites) from breaking the binary, an issue existing work does not handle correctly or at all. We evaluate the prototype implementation of VPS on a diverse set of complex, real-world applications (MongoDB, MySQL server, Node.js, SPEC CPU2017/CPU2006), showing that our approach protects on average 97.8% of all virtual callsites in SPEC CPU2006 and 97.4% in SPEC CPU2017 (all C++ benchmarks), with a moderate performance overhead of 11% and 9% geomean, respectively. Furthermore, our evaluation reveals 86 false negatives in VTV, a popular source-based defense which is part of GCC.\",\n                \"authors\": \"Andre Pawlowski, Victor van der Veen, Dennis Andriesse, Erik van der Kouwe, Thorsten Holz, Cristiano Giuffrida, Herbert Bos\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2020\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"MMv0JncB9MRBP9xUUURi\",\n            \"_score\": 7.352626,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1809.10956\",\n                \"title\": \"Coconut E-Petition Implementation\",\n                \"abstract\": \"In this dissertation project, we describe and implement a practical system application based on a selective disclosure credential scheme, namely the Coconut credential scheme\\\\cite{sonnino_coconut:_2018}. The specific application here is an electronic petition system with the distinctive added feature of unlinkability as well as anonymity: such that no information about the anonymous petition voter is linkable back to the individual. In other words, there is no data leaked about who voted in the petition, just that the users who did, were indeed eligible and authorized to vote. As for the implementation, the client-side is done using JavaScript so that the client can trustlessly compute the cryptographic constructions individually, whereas the server-side is done using Node.js, but can easily be replaced by a more sophisticated and secure structure such as a permissionless blockchain platform.\",\n                \"authors\": \"Jad Wahab\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2018\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"OMv0JncB9MRBP9xUUURi\",\n            \"_score\": 7.737171,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1602.03681\",\n                \"title\": \"Package equivalence in complex software network\",\n                \"abstract\": \"The public package registry npm is one of the biggest software registry. With its 216 911 software packages, it forms a big network of software dependencies. In this paper we evaluate various methods for finding similar packages in the npm network, using only the structure of the graph. Namely, we want to find a way of categorizing similar packages, which would be useful for recommendation systems. This size enables us to compute meaningful results, as it softened the particularities of the graph. Npm is also quite famous as it is the default package repository of Node.js. We believe that it will make our results interesting for more people than a less used package repository. This makes it a good subject of analysis of software networks.\",\n                \"authors\": \"Tomislav Slijepƒçeviƒá\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2016\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"M8v0JncB9MRBP9xUUURi\",\n            \"_score\": 8.641029,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1705.04317\",\n                \"title\": \"Management system for the SND experiments\",\n                \"abstract\": \"A new management system for the SND detector experiments (at VEPP-2000 collider in Novosibirsk) is developed. We describe here the interaction between a user and the SND databases. These databases contain experiment configuration, conditions and metadata. The new system is designed in client-server architecture. It has several logical layers corresponding to the users roles. A new template engine is created. A web application is implemented using Node.js framework. At the time the application provides: showing and editing configuration; showing experiment metadata and experiment conditions data index; showing SND log (prototype).\",\n                \"authors\": \"A. Korol, K. Pugachev\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2017\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Lsv0JncB9MRBP9xUUURi\",\n            \"_score\": 8.9498825,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1811.05945\",\n                \"title\": \"Mayall: A Framework for Desktop JavaScript Auditing and Post-Exploitation Analysis\",\n                \"abstract\": \"Writing desktop applications in JavaScript offers developers the opportunity to write cross-platform applications with cutting edge capabilities. However in doing so, they are potentially submitting their code to a number of unsanctioned modifications from malicious actors. Electron is one such JavaScript application framework which facilitates this multi-platform out-the-box paradigm and is based upon the Node.js JavaScript runtime --- an increasingly popular server-side technology. In bringing this technology to the client-side environment, previously unrealized risks are exposed to users due to the powerful system programming interface that Node.js exposes. In a concerted effort to highlight previously unexposed risks in these rapidly expanding frameworks, this paper presents the Mayall Framework, an extensible toolkit aimed at JavaScript security auditing and post-exploitation analysis. The paper also exposes fifteen highly popular Electron applications and demonstrates that two thirds of applications were found to be using known vulnerable elements with high CVSS scores. Moreover, this paper discloses a wide-reaching and overlooked vulnerability within the Electron Framework which is a direct byproduct of shipping the runtime unaltered with each application, allowing malicious actors to modify source code and inject covert malware inside verified and signed applications without restriction. Finally, a number of injection vectors are explored and appropriate remediations are proposed.\",\n                \"authors\": \"Adam Rapley, Xavier Bellekens, Lynsay A. Shepherd, Colin McLean\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2018\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Ksv0JncB9MRBP9xUUURi\",\n            \"_score\": 15.400597,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/2004.05880\",\n                \"title\": \"SecureIT using Firebase, Google map and Node.Js\",\n                \"abstract\": \"This paper is about describing the features of a software that was developed for its user safety which we called SecureIT is a android based soft ware using Android SDK along with Firebase and Google map SDK along with Node.Js. The aim of developing this project was to make sure and taking its users safety to a next level. Actually now a days some crime incidents like rapes, fire accidents and snatchings are very common and we believe many of those can be prevented if victim got support at the right time. According to the well known daily news paper of Bangladesh The Daily Star there were about 1413 women was rapped where 76 women were dead in 2019. On the same pa-per it also said that in 2018 and 2017 the number of rapes were 732 and 818 where we can easily get that the number increases to almost double in 2019. Where we get a point that if those girls get support or get people known about their location at the right time they might get rid of the situation and the number of rapes could be reduced a lot because we all know that now a days using mo-bile smartphone is too easy for people. Although leading Chinese mobile phone company Xiaomi introduced a new feature Emergency SOS service in their mobile phones at the end of 2018 with a MIUI 10 update but this feature is only limited to the Xiaomi phones and it was well advertised as well. This paper will briefly describe all the features of our software and its usages.\",\n                \"authors\": \"Shanta Khatun, Fahim Hossain Saiki, Milon Biswas\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2020\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Psv0JncB9MRBP9xUUURi\",\n            \"_score\": 34.713425,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/2009.09019\",\n                \"title\": \"On the Threat of npm Vulnerable Dependencies in Node.js Applications\",\n                \"abstract\": \"Software vulnerabilities have a large negative impact on the software systems that we depend on daily. Reports on software vulnerabilities always paint a grim picture, with some reports showing that 83% of organizations depend on vulnerable software. However, our experience leads us to believe that, in the grand scheme of things, these software vulnerabilities may have less impact than what is reported. Therefore, we perform a study to better understand the threat of npm vulnerable packages used in Node.js applications. We define three threat levels for vulnerabilities in packages, based on their lifecycle, where a package vulnerability is assigned a low threat level if it was hidden or still unknown at the time it was used in the dependent application (t), medium threat level if the vulnerability was reported but not yet published at t, and high if it was publicly announced at t. Then, we perform an empirical study involving 6,673 real-world, active, and mature open source Node.js applications. Our findings show that although 67.93% of the examined applications depend on at least one vulnerable package, 94.91% of the vulnerable packages in those affected applications are classified as having low threat. Moreover, we find that in the case of vulnerable packages classified as having high threat, it is the application's lack of updating that makes them vulnerable, i.e., it is not the existence of the vulnerability that is the real problem. Furthermore, we verify our findings at different stages of the application's lifetime and find that our findings still hold. Our study argues that when it comes to software vulnerabilities, things may not be as bad as they seem and that considering vulnerability threat is key.\",\n                \"authors\": \"Mahmoud Alfadel, Diego Elias Costa, Mouafak Mokhallalati, Emad Shihab, Bram Adams\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2020\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        }\n    ]\n}"
				},
				{
					"name": "search title",
					"originalRequest": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"term\": \"node.js\",\r\n    \"author\": \"Mahmoud Alfadel\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{Host}}/api/search/title",
							"host": [
								"{{Host}}"
							],
							"path": [
								"api",
								"search",
								"title"
							]
						}
					},
					"status": "OK",
					"code": 200,
					"_postman_previewlanguage": "json",
					"header": [
						{
							"key": "X-Powered-By",
							"value": "Express"
						},
						{
							"key": "Content-Type",
							"value": "application/json; charset=utf-8"
						},
						{
							"key": "Content-Length",
							"value": "6332"
						},
						{
							"key": "ETag",
							"value": "W/\"18bc-KUQeb5ge0lV/FkIUOrFNZbnaPmw\""
						},
						{
							"key": "Date",
							"value": "Sat, 30 Jan 2021 06:11:29 GMT"
						},
						{
							"key": "Connection",
							"value": "keep-alive"
						}
					],
					"cookie": [],
					"body": "{\n    \"status\": true,\n    \"count\": 4,\n    \"data\": [\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Psv0JncB9MRBP9xUUURi\",\n            \"_score\": 26.729557,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/2009.09019\",\n                \"title\": \"On the Threat of npm Vulnerable Dependencies in Node.js Applications\",\n                \"abstract\": \"Software vulnerabilities have a large negative impact on the software systems that we depend on daily. Reports on software vulnerabilities always paint a grim picture, with some reports showing that 83% of organizations depend on vulnerable software. However, our experience leads us to believe that, in the grand scheme of things, these software vulnerabilities may have less impact than what is reported. Therefore, we perform a study to better understand the threat of npm vulnerable packages used in Node.js applications. We define three threat levels for vulnerabilities in packages, based on their lifecycle, where a package vulnerability is assigned a low threat level if it was hidden or still unknown at the time it was used in the dependent application (t), medium threat level if the vulnerability was reported but not yet published at t, and high if it was publicly announced at t. Then, we perform an empirical study involving 6,673 real-world, active, and mature open source Node.js applications. Our findings show that although 67.93% of the examined applications depend on at least one vulnerable package, 94.91% of the vulnerable packages in those affected applications are classified as having low threat. Moreover, we find that in the case of vulnerable packages classified as having high threat, it is the application's lack of updating that makes them vulnerable, i.e., it is not the existence of the vulnerability that is the real problem. Furthermore, we verify our findings at different stages of the application's lifetime and find that our findings still hold. Our study argues that when it comes to software vulnerabilities, things may not be as bad as they seem and that considering vulnerability threat is key.\",\n                \"authors\": \"Mahmoud Alfadel, Diego Elias Costa, Mouafak Mokhallalati, Emad Shihab, Bram Adams\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2020\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"NMv0JncB9MRBP9xUUURi\",\n            \"_score\": 10.6288,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1704.07887\",\n                \"title\": \"RootJS: Node.js Bindings for ROOT 6\",\n                \"abstract\": \"We present rootJS, an interface making it possible to seamlessly integrate ROOT 6 into applications written for Node.js, the JavaScript runtime platform increasingly commonly used to create high-performance Web applications. ROOT features can be called both directly from Node.js code and by JIT-compiling C++ macros. All rootJS methods are invoked asynchronously and support callback functions, allowing non-blocking operation of Node.js applications using them. Last but not least, our bindings have been designed to platform-independent and should therefore work on all systems supporting both ROOT 6 and Node.js.\\nThanks to rootJS it is now possible to create ROOT-aware Web applications taking full advantage of the high performance and extensive capabilities of Node.js. Examples include platforms for the quality assurance of acquired, reconstructed or simulated data, book-keeping and e-log systems, and even Web browser-based data visualisation and analysis.\",\n                \"authors\": \"Theo Beffart, Maximilian Fr√ºh, Christoph Haas, Sachin Rajgopal, Jonas Schwabe, Christoph Wolff, Marek Szuba\",\n                \"rank\": \"0.5\",\n                \"citation\": \"2\",\n                \"year\": \"2017\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Ksv0JncB9MRBP9xUUURi\",\n            \"_score\": 10.139733,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/2004.05880\",\n                \"title\": \"SecureIT using Firebase, Google map and Node.Js\",\n                \"abstract\": \"This paper is about describing the features of a software that was developed for its user safety which we called SecureIT is a android based soft ware using Android SDK along with Firebase and Google map SDK along with Node.Js. The aim of developing this project was to make sure and taking its users safety to a next level. Actually now a days some crime incidents like rapes, fire accidents and snatchings are very common and we believe many of those can be prevented if victim got support at the right time. According to the well known daily news paper of Bangladesh The Daily Star there were about 1413 women was rapped where 76 women were dead in 2019. On the same pa-per it also said that in 2018 and 2017 the number of rapes were 732 and 818 where we can easily get that the number increases to almost double in 2019. Where we get a point that if those girls get support or get people known about their location at the right time they might get rid of the situation and the number of rapes could be reduced a lot because we all know that now a days using mo-bile smartphone is too easy for people. Although leading Chinese mobile phone company Xiaomi introduced a new feature Emergency SOS service in their mobile phones at the end of 2018 with a MIUI 10 update but this feature is only limited to the Xiaomi phones and it was well advertised as well. This paper will briefly describe all the features of our software and its usages.\",\n                \"authors\": \"Shanta Khatun, Fahim Hossain Saiki, Milon Biswas\",\n                \"rank\": \"0\",\n                \"citation\": \"0\",\n                \"year\": \"2020\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        },\n        {\n            \"_index\": \"software\",\n            \"_type\": \"ComputerScience\",\n            \"_id\": \"Ocv0JncB9MRBP9xUUURi\",\n            \"_score\": 9.693692,\n            \"_source\": {\n                \"url\": \"https://arxiv.org/abs/1507.02798\",\n                \"title\": \"A horizontally-scalable multiprocessing platform based on Node.js\",\n                \"abstract\": \"This paper presents a scalable web-based platform called Node Scala which allows to split and handle requests on a parallel distributed system according to pre-defined use cases. We applied this platform to a client application that visualizes climate data stored in a NoSQL database MongoDB. The design of Node Scala leads to efficient usage of available computing resources in addition to allowing the system to scale simply by adding new workers. Performance evaluation of Node Scala demonstrated a gain of up to 74 % compared to the state-of-the-art techniques.\",\n                \"authors\": \"Ahmad Maatouki, Marek Szuba, J√∂rg Meyer, Achim Streit\",\n                \"rank\": \"1.5\",\n                \"citation\": \"9\",\n                \"year\": \"2015\",\n                \"tags\": [\n                    \"Node.js\",\n                    \"AllFields\"\n                ],\n                \"status\": \"\"\n            }\n        }\n    ]\n}"
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "Host",
			"value": "http://127.0.0.1:3000"
		}
	]
}